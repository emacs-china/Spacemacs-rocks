# -*- mode: org; -*-

#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="http://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>

#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="http://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>

#+AUTHOR: zilongshanren
#+CREATOR: li-xinyang
#+TITLE: Master Emacs in 21 Days
#+EMAIL: guanghui.qu@cocos2d-x.org
#+OPTIONS: toc:3 num:nil
#+STARTUP: showall


* Spacemacs Rocks 第二季

#+CAPTION: Spacemacs Rocks Artwork
[[./Artwork.png]]

在这一季中我们计划用 21 天的时间内学习 Emacs 以及 Spacemacs 的使用。从基础安装开始到可以运用到工作生产环节中。为了确保学习质量，请务必完成和理解计划中的每一项学习任务。

* 第一天：准备开始

视频地址如下

-  [[http://v.youku.com/v_show/id_XMTUwNjU0MjE0OA==.html][优酷视频]]
-  [[http://pan.baidu.com/s/1gep9DQV][百度网盘]]
-  [[https://www.youtube.com/watch?v=2Q0MhOR59u8][YouTube]]

*说在最前面*

如果你第一次听说 Emacs 你可以在[[http://emacs.sexy/][性感的 Emacs（Emacs is Sexy）]]一文中找到使用它的理由！我相信你一定被它的强大所吸引。

如果你还没有安装 Emacs 可以在 [[http://emacsformacosx.com/builds][Mac OS X 安装链接]]以及 [[http://emacsbinw64.sourceforge.net/][Window 安装链接]]找到它。

在开始本教程之前请务必先完成 Emacs 提供的官方教程（完成时间大约 30 分钟），它可以通过使用 =C-h t= （同时按住 Ctrl 与 h 键，接着按 t 键 =t= 在这里代表 tutorial） 在 Emacs 中直接将其打开。

Elisp 是 Emacs 所用的编程语言，你可以在阅读[[https://learnxinyminutes.com/docs/elisp/][这篇教程（Learn X in Y Minutes）]]后很快的了解它的基础用法。

*** 基础操作

因为 Control 键在 Emacs 中极为常用所以为了更方便的使用 Emacs 的键位修改，需要对其做出修改。建议将大写锁定键（Caps Lock）替换为 Control 键。这里是一个可以参考的把大写锁定键替换为 Control 键的教程：[[https://www.emacswiki.org/emacs/MovingTheCtrlKey][移动 Control 键 (Moving The Ctrl Key)。]]如果这个的教程不适用于你的操作系统，请自行搜索其它的修改方式。

常见符号所代表的意义如下

-  M(eta)，在 Mac 下为 Option 键
-  s(uper)，在 Mac 环境下为左 Command 键
-  S(Shift)
-  C(trl)

光标的移动是编辑器中最常用的操作所以必须熟知。

-  =C-f= 为前移一个字符， =f= 代表 forward。
-  =C-b= 为后移一个字符， =b= 代表 backward。
-  =C-p= 为上移至前一行， =p= 代表 previous。
-  =C-n= 为上移至下一行， =n= 代表 next。
-  =C-a= 为移至行首， =a= 可以理解为最前端。
-  =C-e= 为移至行尾， =e= 代表 end。

常用的文件操作快捷键组合也必须熟记。

-  =C-x C-f= 为打开目标文件， =f= 代表 find/file
-  =C-x C-s= 为保存当前缓冲区（Buffer）， =s= 代表 save

=C-x= 是 Emacs 的快捷键中常用的前缀命令。这些前缀命令常常代表了一系列有关联的指令，十分重要，请特别牢记。其它常见的还有 =C-c=, =C-h= 。
打断组合键为 =C-g= 用于终端取消之前的指令。快捷键就是用预先绑定好的方式告诉 Emacs 去执行指定的命令。（之后会介绍到更多有关绑定的内容）

*** 内置功能

Emacs 功能强大，但是部分功能默认情况下并为开启。下面做有几个例子，

编辑器内显示行号可使用 =M-x linum-mode= 来开启。

*获取帮助*

Emacs 是一个富文档编辑器（Self document, extensible editor）而下面的三种方法在学习 Emacs 的过程中也非常重要。他们分别是，

-  =C-h k= 寻找快捷键的帮助信息
-  =C-h v= 寻找变量的帮助信息
-  =C-h f= 寻找函数的帮助信息

*** 学习基础 Elisp

请务必完成[[https://learnxinyminutes.com/docs/elisp/][这篇教程（Learn X in Y Minutes）]]来了解 Elisp 的使用（阅读时间大约 15 分钟），你也可以在[[https://learnxinyminutes.com/docs/zh-cn/elisp-cn/][这里]]找到它的中文版。Elisp 为一个函数式的语言，所以它全部功能都是由函数来实现的。

下面为一些简单的例子

#+BEGIN_EXAMPLE
    ;; 2 + 2
    (+ 2 2)

    ;; 2 + 3 * 4
    (+ 2 (* 3 4))

    ;; 定义变量
    (setq name "username")
    (messasge name) ; -> "username"

    ;; 定义函数
    (defun func()
      (message "Hello, %s" username))

    ;; 执行函数
    (func) ; -> Hello, username

    ;; 设置快捷键
    (global-set-key (kbd "<f1>") 'func)

    ;; 使函数可直接被调用可添加 (interactive)
    (defun func()
      (interactive)
      (message "Hello, %s" username))
#+END_EXAMPLE

*** 开始 Hacking！

Emacs 的配置文件默认保存在 =~/.emacs.d/init.el= 文件中。（如果其不存在可自行创建，配置文件也可保存在 =~/.emacs= 文件中，他们之间的区别我们会在后面做讨论）

在开始配置之前让我们先来区别 Emacs 中 Major Mode 与 Minor Mode 的区别。Major Mode 通常是定义对于一种文件类型编辑的核心规则，例如语法高亮、缩进、快捷键绑定等。而 Minor Mode 是除去 Major Mode 所提供的核心功能以外的额外编辑功能（辅助功能）。例如在下面的配置文件中 =tool-bar-mode= 与 =linum-mode= 等均为 Minor Mode*。

简单来说就是，一种文件类型同时只能存在一种 Major Mode 但是它可以同时激活一种或多种 Minor Mode。如果你希望知道当前的模式信息，可以使用 =C-h m= 来显示当前所有开启的全部 Minor Mode 的信息。

*简单的编辑器自定义*

下面是一些简单的编辑器配置信息，你需要做的就是将其写入你的配置文件中（ =~/.emacs.d/init.el= ）即可。

#+BEGIN_EXAMPLE
    ;; 关闭工具栏 tool-bar-mode 即为一个 Minor Mode
    (tool-bar-mode -1)

    ;; 关闭文件滑动控件
    (scroll-bar-mode -1)

    ;; 显示行号
    (global-linum-mode t)

    ;; 更改光标的样式（不能生效，解决方案见第二集）
    (setq cursor-type 'bar)

    ;; 关闭启动帮助画面
    (setq inhibit-splash-screen t)

    ;; 关闭缩进 (第二天中被去除)
    ;; (electric-indent-mode -1)

    ;; 更改显示字体大小 16pt
    ;; http://stackoverflow.com/questions/294664/how-to-set-the-font-size-in-emacs
    (set-face-attribute 'default nil :height 160)

    ;; 快速打开配置文件
    (def open-init-file()
      (interactive)
      (find-file "~/.emacs.d/init.el"))

    ;; 这种快捷键，将函数 open-init-file 绑定 <f2> 键
    (global-set-key (kbd "<f2>") 'open-init-file)
#+END_EXAMPLE

在每次编辑配置文件后，刚刚做的修改并不会立刻生效。这时你需要重启编辑器或者重新加载配置文件。重新加载配置文件你需要在当前配置文件中使用 =M-x load-file= 双击两次回车确认默认文件名，或者使用 =M-x eval-buffer= 去执行当前缓冲区的所以 Lisp 命令。你也可以使用 =C-x C-e= 来执行某一行的 Lisp 代码。这些可使刚刚修改的配置文件生效。当然你也可以将他们绑定为快捷键。

*** 插件管理

使用默认的插件管理系统（可在菜单栏中找到 =Options > Manage Emacs Packages= 中），安装 [[http://company-mode.github.io/][Company]] 插件，他是一个用于代码补全的插件。它的名字代表补全一切的意思（Complete Anything）。因为默认的插件管理系统提供的插件十分有限，所以我们会在之后的几天中继续将其强化。

使用的下面的配置将 Comany-mode 在全局模式下激活

#+BEGIN_EXAMPLE
    ; 开启全局 Company 补全
    (global-company-mode t)
#+END_EXAMPLE

*** Org-mode

简单的 Org-mode 的使用，它可以列出提纲并方便的使用 =tab= 键来对其经行展开与关闭。 ~C-c C-t~ 可以将一个条目转换成一条待办事件。

#+BEGIN_EXAMPLE
    * 为一级标题
    ** 为二级标题
    *** 为三级标题并以此类推
#+END_EXAMPLE

*** COMMENT Comment On this Chapter
It will be better to briefly introduce a little about org-mode and literate programming.

* 第二天：高级自定义

视频地址如下

-  [[http://v.youku.com/v_show/id_XMTUxMzQyODI4MA==.html][优酷视频]]
-  [[http://pan.baidu.com/s/1c2Cw9ck][百度网盘]]
-  [[https://youtu.be/aQRZxaU3pAI][YouTube]]

*说在最前面*

如果你想深入学习 Emacs Lisp 可以阅读 GNU 提供的 [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in Emacs Lisp]] 。（ =M-x info= 然后选择 Emacs Lisp Intro）

我们先解决前一天中遇到的一些问题。首先是区分 =setq= 与 =setq-default= 的区别， =setq= 为设置当前缓冲区（Buffer）中的变量值， =setq-default= 设置的为全局的变量的值（具体内容可以在 [[http://stackoverflow.com/questions/18172728/the-difference-between-setq-and-setq-default-in-emacs-lisp][StackOverflow 找到]]）。下面是一个例子，用于设置光标样式的方法。

#+BEGIN_EXAMPLE
    (setq-default cursor-type 'bar)
#+END_EXAMPLE

今天我们需要将第一天关闭的自动缩进(=electric-indent-mode=)从配置文件中去除，它是 Emacs 24.4 中加入的新特性，你可以在这篇[[http://emacsredux.com/blog/2014/01/19/a-peek-at-emacs-24-dot-4-auto-indentation-by-default/][文章]]中找到更多关于它的内容。我们之前关闭它是因为，它存在不理想的缩进效果（在 Eli 中用分号做注释时 =fancy-comment= 会造成很远的缩进，其实解决方法是使用 Elisp 推荐的两个分号而不是一个 =;;= ，这样就可以避免这个问题。于是我们也就将其从配置文件中删除）

因为通常我们的配置文件以及项目文件均使用版本控制系统，所以自动生成的备份文件就显得有些多余。我们还可以禁止 Emacs 自动生成备份文件，例如 =init.el~= 。（ =~= 为后缀的文件为自动生成的备份文件）我们可以使用下面的方法将其关闭。

#+BEGIN_EXAMPLE
    (setq make-backup-files nil)
#+END_EXAMPLE

关于分屏的使用，如果你已经读过 Emacs 自带的教程，现在你应该已经掌握了基本的分屏操作方法了。关于分屏的更多内容你可以在[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Split-Window.html][这里]]找到。

-  =C-x 1= 仅保留当前窗口
-  =C-x 2= 将当前窗口分到上边
-  =C-x 3= 将当前窗口分到右边

使用下面的配置来加入最近打开过文件的选项让我们更快捷的在图形界面的菜单中打开最近编辑过的文件。

#+BEGIN_EXAMPLE
    (require 'recentf)
    (recentf-mode 1)
    (setq recentf-max-menu-item 10)

    ;; 这个快捷键绑定可以用之后的插件 counsel 代替
    ;; (global-set-key "\C-x\ \C-r" 'recent-open-files)
#+END_EXAMPLE

=require= 的意思为从文件中加载特性，你可以在杀哥的网站读到关于 Emacs Lisp 库系统的更多内容，文章在[[http://ergoemacs.org/emacs/elisp_library_system.html][这里]]。

使用下面的配置文件将删除功能配置成与其他图形界面的编辑器相同，

#+BEGIN_EXAMPLE
    (delete-selection-mode t)
#+END_EXAMPLE

下面的这些函数可以让你找到不同函数，变量以及快捷键所定义的文件位置。因为非常常用所以我们建议将其设置为与查找文档类似的快捷键（如下所示），

-  =find-function= （ =C-h C-f= ）
-  =find-variable= （ =C-h C-v= ）
-  =find-function-on-key= （ =C-h C-k= ）

在我们进入下一个部分之间让我们来看看使用 =~/.emacs.d/init.el= 与 =~/.emacs= 的区别（更多关于他们区别的讨论可在[[http://emacs.stackexchange.com/questions/1/are-there-any-advantages-to-using-emacs-d-init-el-instead-of-emacs][这里]]找到） 简单来说请使用前者因为它有下面的两个优点，

-  它可以更好将所有 Emacs 相关的文件整合在一个目录内（干净的 =HOME= ，网盘备份等优点）
-  更好的版本控制

*** Emacs 也很美

*配置插件源*

在进行美化之前我们需要配置插件的源（默认的源非常有限），最常使用的是 [[https://melpa.org/][MELPA]] （Milkypostman's Emacas Lisp Package Archive）它有非常多的插件（3000 多个插件）。下载的次数并不能说明它非常有用，也许这个插件是其他的插件依赖。在[[https://melpa.org/#/getting-started][这里]]你可以找到其安装使用方法。添加源后，我们就可以使用 =M-x package-list-packages= 来查看所有 MELPA 上的插件了。在表单中可以使用 =I= 来标记安装 =D= 来标记删除， =U= 来更新，并用 =X= 来确认。

你可以直接将下面的代码复制到你的配置文件顶端，从而直接使用 Melpa 作为插件的源。你可以将你需要的插件名字写在 =YOUR_NAME_HERE/packages= 中，Emacs 在启动时会自动下载未被安装的插件。

#+BEGIN_EXAMPLE
    (when (>= emacs-major-version 24)
        (require 'package)
        (package-initialize)
        (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
        )

    ;; cl - Common Lisp Extension
    (require 'cl)

    ;; Add Packages
    (defvar YOUR_NAME_HERE/packages '(
                   ;; --- Auto-completion ---
                   company
                   ;; --- Better Editor ---
                   hungry-delete
                   swiper
                   counsel
                   smartparens
                   ;; --- Major Mode ---
                   js2-mode
                   ;; --- Minor Mode ---
                   nodejs-repl
                   exec-path-from-shell
                   ;; --- Themes ---
                   monokai-theme
                   ;; solarized-theme
                   ) "Default packages")

    (setq package-selected-packages YOUR_NAME_HERE/packages)

    (defun YOUR_NAME_HERE/packages-installed-p ()
        (loop for pkg in YOUR_NAME_HERE/packages
              when (not (package-installed-p pkg)) do (return nil)
              finally (return t)))

    (unless (YOUR_NAME_HERE/packages-installed-p)
        (message "%s" "Refreshing package database...")
        (package-refresh-contents)
        (dolist (pkg YOUR_NAME_HERE/packages)
          (when (not (package-installed-p pkg))
            (package-install pkg))))

    ;; Find Executable Path on OS X
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize))
#+END_EXAMPLE

关于上面这段配置代码有几个知识点，首先就是这段配置文件中用到了 =loop for ... in= ，它来自 =cl= 既 Common Lisp 扩展。 =for= , =in=, =collection= 均为 =cl-loop= 中的保留关键字。下面是一些简单的 =cl-loop= 的使用示例，

#+BEGIN_SRC lisp
    ;; 遍历每一个缓冲区（Buffer）
    (cl-loop for buf in (buffer-list)
                     collection (buffer-file-name buf))

    ;; 寻找 729 的平方根（设置最大为 100 为了防止无限循环）
    (cl-loop for x from 1 to 100
                     for y = (* x x)
                     until (>= y 729)
                     finally return (list x (= y 729)))
#+END_SRC

你可以在[[http://www.gnu.org/software/emacs/manual/html_mono/cl.html#Loop-Facility][这里]]找到更多关于循环的使用说明。

其次就是它使用到了 =quote=, 它其实就是我们之前常常见到的 ='=（单引号）的完全体。因为它在 Lisp 中十分常用，所以就提供了简写的方法。

#+BEGIN_SRC lisp
    ;; 下面两行的效果完全相同的
    (quote foo)
    'foo
#+END_SRC

=quote= 的意思是不要执行后面的内容，返回它原本的内容（具体请参考下面的例子）

#+BEGIN_EXAMPLE
    (print '(+ 1 1)) ;; -> (+ 1 1)
    (print (+ 1 1))  ;; -> 2
#+END_EXAMPLE

更多关于 =quote= 的内容可以在[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Quoting.html][这里]]找到，或者在[[http://stackoverflow.com/questions/134887/when-to-use-quote-in-lisp][这里]]找到 StackOverflow 上对于它的讨论。

这样我们就可以区分下面三行代码的区别，

#+BEGIN_SRC lisp
    ;; 第一种
    (setq package-selected-packages YOUR_NAME_HERE/packages)
    ;; 第二种
    (setq package-selected-packages 'YOUR_NAME_HERE/packages)
    ;; 第三种
    (setq package-selected-packages (quote YOUR_NAME_HERE/packages))
#+END_SRC

第一种设置是在缓冲区中设置一个名为 =package-selected-packages= 的变量，将其的值设定为 =YOUR_NAME_HERE/packages= 变量的值。第二种和第三种其实是完全相同的，将一个名为 =package-selected-packages= 的变量设置为 =YOUR_NAME_HERE/packages= 。

我们可以用下面代码将 Emacs 设置为开启默认全屏，

#+BEGIN_EXAMPLE
    (setq initial-frame-alist (quote ((fullscreen . maximized))))
#+END_EXAMPLE

我们也可以启用自动括号匹配（Highlight Matching Parenthesis），随后会介绍插件来增强这个匹配的功能。你可以在[[https://www.gnu.org/software/emacs/manual/html_node/emacs/Hooks.html][这里]]读到关于钩子的更多信息。

#+BEGIN_EXAMPLE
    (add-hook 'emacs-lisp-mode-hook 'show-paren-mode)
#+END_EXAMPLE

高亮当前行，当文本内容很多时可以很容易找到光标的位置。

#+BEGIN_EXAMPLE
    (global-hl-line-mode t)
#+END_EXAMPLE

*安装主题*

#+BEGIN_EXAMPLE
    (add-to-list 'monokai-theme)
#+END_EXAMPLE

然后使用下面的配置使其每次打开编辑器时加载主题，

#+BEGIN_EXAMPLE
    (load-theme 'monokai t)
#+END_EXAMPLE

*推荐插件*

-  [[http://company-mode.github.io/][company]]
-  [[https://github.com/nflath/hungry-delete][hungry-delete]]
-  [[https://github.com/nonsequitur/smex][Smex]] (如果你使用 Counsel 来增强你的 ~M-x~ ，那么就不需要再安装 Smex 了)
-  [[https://github.com/abo-abo/swiper][Swiper & Counsel]]
-  [[https://github.com/Fuco1/smartparens][smartparens]]

使用 =M-x customize-group= 后选择对应的插件名称，可以进入可视化选项区对指定的插件做自定义设置。当选择 Save for future session 后，刚刚做的设计就会被保存在你的配置文件（ =init.el= ）中。关于各个插件的安装与使用方法通常都可以在其官方页面找到（GitHub Pages 或者是项目仓库中的 README 文件）。我们强烈建议大家在安装这些插件后阅读使用方法来更好的将它们使用到你的日常工作当中使效率最大化。

*** COMMENT About the source code
I hope, however, you have read, or consulted, the code convention or standard of some 
authority or google coding standard.

*** JavaScript IDE

Emacs 提供的默认 JavaScript Major Mode 并不是非常好用。所以我们可以将默认的模式替换成 [[https://github.com/mooz/js2-mode][js2-mode]] 一个比默认模式好用的 Major Mode。我们可以通过 MELPA 来下载它，然后用下面的代码将其启用。

#+BEGIN_EXAMPLE
    (setq auto-mode-alist
          (append
           '(("\\.js\\'" . js2-mode))
           auto-mode-alist))
#+END_EXAMPLE

你可以在[[https://www.gnu.org/software/emacs/manual/html_node/elisp/Auto-Major-Mode.html][这里]]（How Emacs Chooses a Major Mode）找到 Emacs 是如何选择何时该选用何种 Major Mode 的方法。

在这里我们需要知道 =auto-mode-alist= 的作用，这个变量是一个 [[https://www.emacswiki.org/emacs/AssociationList][AssociationList]]，它使用正则表达式（REGEXP）的规则来匹配不同类型文件应使用的 Major Mode。 下面是几个正则表达式匹配的例子，

#+BEGIN_SRC lisp
    (("\\`/tmp/fol/" . text-mode)
     ("\\.texinfo\\'" . texinfo-mode)
     ("\\.texi\\'" . texinfo-mode)
     ("\\.el\\'" . emacs-lisp-mode)
     ("\\.c\\'" . c-mode)
     ("\\.h\\'" . c-mode)
     …)
#+END_SRC

下面是如何添加新的模式与对应文件类型的例子（与我们配置 =js2-mode= 时相似的例子），

#+BEGIN_SRC lisp
    (setq auto-mode-alist
      (append
       ;; File name (within directory) starts with a dot.
       '(("/\\.[^/]*\\'" . fundamental-mode)
         ;; File name has no dot.
         ("/[^\\./]*\\'" . fundamental-mode)
         ;; File name ends in ‘.C’.
         ("\\.C\\'" . c++-mode))
       auto-mode-alist))
#+END_SRC

在 =js2-mode= 模式中会提供

-  语法高亮
-  语法检查器（Linter）

执行缓冲区的代码可以使用 =nodejs-repl= 插件，它需要你的机器上已经安装了 NodeJS。然而在 Mac OS X 上可能会出现找不到 NodeJS 可执行文件的问题，要解决这个问题你需要安装另外一个 =exec-path-from-shell= 的插件并将其启用。

#+BEGIN_EXAMPLE
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize))
#+END_EXAMPLE

有了 =nodejs-repl= 我们就可以方便的测试和开发我们的 JavaScript 代码了（你可以在[[https://github.com/mooz/js2-mode][这里]]找到更多关于它的使用方法）。

*** Org-mode 进阶

在 Org-mode 中你可以直接开启新的缓冲区（Buffer）直接用相应的 Major Mode 来编辑代码块内的内容。在代码块中使用 ~C-c '~ 会直接打开对应模式的缓冲区（不仅限于 Lisp）。这样就使在 Org-mode 中编辑代码变的十分方便快捷。

使用 =<s= 然后 Tab 可以直接插入代码块的代码片段（Snippet），更多类似的代码片段（Org-mode Easy Templates）可以在[[http://orgmode.org/manual/Easy-Templates.html][这里]]找到。

#+BEGIN_EXAMPLE
     #+BEGIN_SRC emacs-lisp
     ;; Your code goes here
     ;; 你的代码写在这里
     #+END_SRC
#+END_EXAMPLE

*添加 Org-mode 文本内语法高亮*

#+BEGIN_EXAMPLE
    (require 'org)
    (setq org-src-fontify-natively t)
#+END_EXAMPLE

在 Org-mode 中重置有序列表序号可以直接使用 M-<RET> 。

*Agenda 的使用*

#+BEGIN_EXAMPLE
    ;; 设置默认 Org Agenda 文件目录
    (setq org-agenda-files '("~/org"))

    ;; 设置 org-agenda 打开快捷键
    (global-set-key (kbd "C-c a") 'org-agenda)
#+END_EXAMPLE

你只需将你的 =*.org= 文件放入上面所指定的文件夹中就可以开始使用 Agenda
模式了。

-  =C-c C-s= 选择想要完成的时间
-  =C-c C-d= 选择想要结束的时间
-  =C-c a= 可以打开 Agenda 模式菜单并选择不同的可视方式（ =r= ）
* 第三天：配置文件模块化（上）

视频地址如下

- [[http://v.youku.com/v_show/id_XMTUyNzA0MTMxNg%3D%3D.html?f%3D26962151&o%3D1][优酷视频]]
- [[http://pan.baidu.com/s/1nuJWyLF][百度网盘]]
- [[https://www.youtube.com/watch?v%3DZ83xnsiLtI0&feature%3Dyoutu.be][YouTube]]

** 多文件存储配置文件(上)

将不同的配置代码放置到不同的文件中，使其模块化，这让我们的后续维护变得更加简单。下面是我们现在的 =~/.emacs.d/= 目录中的样子，

#+BEGIN_EXAMPLE
├── auto-save-list # 自动生成的保存数据
├── elpa           # 下载的插件目录
├── init.el        # 我们的配置文件
└── recentf        # 最近访问的文件列表
#+END_EXAMPLE

通常我们只保存配置文件和对其进行版本控制，其他的插件均为在第一次使用编辑器时再通过网络重新下载，当然你也可以选择将全部配置文件进行版本控制来保证自己时刻拥有最稳定的生产环境。

Elisp 中并没有命名空间（Namespace），换句话说就是所有的变量均为全局变量，所以其命名方法就变的非常重要。下面是一个简单的命名规则，

#+BEGIN_EXAMPLE
#自定义变量可以使用自己的名字作为命名方式（可以是变量名或者函数名）
YourName/XXXX

#模式命名规则
ModeName-mode

#模式内的变量则可以使用
ModeName-VariableName
#+END_EXAMPLE

遵守上面的命名规则可以最大程度的减少命名冲突发生的可能性。

现在我们想将原本混合在一起的配置文件分为下面的几个模块（每一个模块为一个独立的配置文件并将其保存在指定的子目录中），它们分别是

#+BEGIN_EXAMPLE
init-packages.el        # 插件管理
init-ui.el              # 视觉层配置
init-better-defaults.el # 增强内置功能
init-keybindings.el     # 快捷键绑定
init-org.el             # Org 模式相关的全部设定
custome.el              # 存放使用编辑器接口产生的配置信息
#+END_EXAMPLE

下面为将配置文件进行模块化后的目录结构，

#+BEGIN_EXAMPLE
├── init.el
└── lisp
    ├── comstom.el
    ├── init-better-defaults.el
    ├── init-helper.el
    ├── init-keybindings.el
    ├── init-packages.el
    ├── init-ui.el
    └── init-org.el
#+END_EXAMPLE

使用模块化配置就可以让我们在之后的配置中迅速的定位与更改配置内容，让整个过程变得更有条理也更加高效。

和之前一样 ~init.el~ 是配置文件的入口，现在它便成为了所有模块配置文件的入口，所以要使用这些模块时，我们需要在其中引用需要加载的模块。下面以 ~init-packages.el~ （此配置为添加插件的模块） 为例，详细说明如何模块化以及应用的方法。

下面是在模块化配置之前，我们所使用的配置文件 =~/.emacs.d/init.el= 的样子，我们将所有的配置代码都放置在了同一个文件中（如下所示）

下面为 =~/.emacs.d/init.el= 文件的内容

#+BEGIN_SRC lisp
;;  __        __             __   ___
;; |__)  /\  /  ` |__/  /\  / _` |__
;; |    /~~\ \__, |  \ /~~\ \__> |___
;;                      __   ___        ___      ___
;; |\/|  /\  |\ |  /\  / _` |__   |\/| |__  |\ |  |
;; |  | /~~\ | \| /~~\ \__> |___  |  | |___ | \|  |
(when (>= emacs-major-version 24)
    (require 'package)
    (package-initialize)
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") 1))

;; cl - Common Lisp Extension
(require 'cl)

;; Add Packages
(defvar xinyang/packages '(
			   ;; --- Auto-completion ---
			   company
			   ;; --- Better Editor ---
			   smooth-scrolling
			   hungry-delete
			   swiper
			   counsel
			   smartparens
			   ;; --- Major Mode ---
			   js2-mode
			   markdown-mode
			   ;; --- Minor Mode ---
			   ;; Quick Note Taking
			   deft
			   ;; JavaScript REPL
			   nodejs-repl
			   ;; Find OS X Executable Helper Package
;; ...
#+END_SRC

之前为了更好的区分不同的区域我使用的方法是使用 ASCII Art 然后再以关键字来做搜索跳转，但是这样再编辑工程中依旧十分缓慢和麻烦。于是我们现在要将配置文件全部模块化，把不同部分的配置代码放置在不同的配置文件中，并在入口文件（ =~/.emacs.d/init.el= ）中依次引用不用的模块。

下面为 =~/.emacs.d/lisp/init-packages.el= 模块中的代码

#+BEGIN_SRC lisp
;;  __        __             __   ___
;; |__)  /\  /  ` |__/  /\  / _` |__
;; |    /~~\ \__, |  \ /~~\ \__> |___
;;                      __   ___        ___      ___
;; |\/|  /\  |\ |  /\  / _` |__   |\/| |__  |\ |  |
;; |  | /~~\ | \| /~~\ \__> |___  |  | |___ | \|  |
(when (>= emacs-major-version 24)
    (require 'package)
    (package-initialize)
    (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") 1))

;; cl - Common Lisp Extension
(require 'cl)

;; Add Packages
(defvar xinyang/packages '(
			   ;; --- Auto-completion ---
			   company
			   ;; --- Better Editor ---
			   smooth-scrolling
			   hungry-delete
			   swiper
			   counsel
			   smartparens
			   popwin
			   ;; --- Major Mode ---
			   js2-mode
			   markdown-mode

;; ...

;; 文件末尾
(provide 'init-packages)
#+END_SRC

下面为 =~/.emacs.d/init.el= 入口文件中的代码

#+BEGIN_SRC lisp
(package-initialize)

(add-to-list 'load-path "~/.emacs.d/lisp/")

;; Package Management
;; -----------------------------------------------------------------
(require 'init-packages)
#+END_SRC

模块化要做的其实非常简单，我们要做的其实就是把某一个更改编辑器某定部分（例如，插件管理，显示层，快捷键绑定等）的配置代码写入一个独立的文件中并在末尾为其添加 =(provide 'modul-name)= (这里我们的模块名为 =init-packages= )使其可以在入口文件中被调用，然后再在入口文件中将其引用既可。

这里需要注意的是，我们需要在入口文件中添加 =(add-to-list 'load-path "~/.emacs.d/lisp/")= 这可以让 Emacs 找到需要加载的模块所处的位置。

更多模块化的配置文件可以在[[https://github.com/zilongshanren/Learning-Emacs/tree/day3][这里]]找到。

** Major 与 Minor Mode 详解

在这一节我们将详细介绍 Major Mode 与 Minor Mode 去区别。每一个文件类型都对应一个 Major Mode，它提供语法高亮以及缩进等基本的编辑支持功能，然后而 Minor Mode 则提供其余的增强性的功能（例如 ~linum-mode~ ）。

在 Emacs 中，Major Mode 又分为三种，

- ~text-mode~ ，用于编辑文本文件
- ~special-mode~ ，特殊模式（很少见）
- ~prog-mode~ ，所有的编程语言的父模式

# TODO: Explan what is prog-mode

在每一个模式（mode）中它的名称与各个变量还有函数都是有特定的命名规则，比如所有的模式都被命名为 ~ModeName-mode~ ，里面所设置的快捷键则为 ~ModeName-mode-key-map~ ，而所有的钩子则会被命名为 ~ModeName-mode-hook~ 。

注明：为了保持阅读的完整性，部分第三天的关于默认编辑器优化的内容被移至第四天。

* 第四天：配置文件模块化（下）以及使用优化

视频地址如下

- [[http://v.youku.com/v_show/id_XMTUzMDAwMDYwMA%3D%3D.html][优酷视频]]
- [[http://pan.baidu.com/s/1o8QWrHK][百度网盘]]
- [[https://www.youtube.com/watch?v%3DBGecmDgPAiw][YouTube]]

** 配置文件模块化（下）

在这一部分我们首先需要知道的是什么是 =features= 。在 Emacs 中每一个 =feature= 都是一个 Elisp 符号，用于代表一个 Lisp 插件（Package）。

当一个插件调用 =(provide 'symbol_name)= 函数时，Emacs 就会将这个符号加入到 =features= 的列表中去。你可以在[[http://ergoemacs.org/emacs/elisp_feature_name.html][这里]]读到更多关于 feature 的内容。

接着我们需要弄明白的是 =load-file= , =load= , =require= , =autoload= 之间的区别。（他们之间区别的链接已经再前面贴过了，你也可以在[[http://ergoemacs.org/emacs/elisp_library_system.html][这里]]找到之前同样的链接）

简单来说， =load-file= 用于打开某一个指定的文件，用于当你不想让 Emacs 来去决定加载某个配置文件时（ =.el= 或者 =.elc= 文件）。

=load= 搜索 =load-path= 中的路径并打开第一个所找到的匹配文件名的文件。此方法用于你预先不知道文件路径的时候。

=require= 加载还未被加载的插件。首先它会查看变量 =features= 中是否存在所要加载的符号如果不存在则使用上面提到的 =load= 将其载入。（有点类似于其他编程语言中的 =import= ）

=autoload= 用于仅在函数调用时加载文件，使用此方法可以大大节省编辑器的启动时间。

# TODO: 补充魔法注释的内容

** 更好的默认设置

在这一节我们会配置我们的编辑器使其有更好的使用体验。整个过程就如同搭积木一般，将更好的体验建立在已有的功能基础之上。这样的优化使整个过程变得更高效，也更有趣。

下面的代码可以是 Emacs 自动加载外部修改过的文件。

#+BEGIN_EXAMPLE
(global-auto-revert-mode t)
#+END_EXAMPLE

使用下面的代码可以关闭自己生产的保存文件（之前我们已经关闭过了 Emacs 自动生产的备份文件了，现在是关闭自动保存文件）。

#+BEGIN_EXAMPLE
(setq auto-save-default nil)
#+END_EXAMPLE

如果你发现你在使用中发现了那些编辑行为与你预期的不相符时，你可以通过搜索引擎去寻找解决方案然后将其加入你的配置中并打造一个真正属于你的神器！

=popwin= 插件可以自动将光标移动到，新创建的窗口中。使用下面的代码将其启用，

#+BEGIN_EXAMPLE
(require 'popwin)
(popwin-mode t)
#+END_EXAMPLE

也许你并不喜欢听到错误时的“哔哔”的警告提示音，使用下面的代码你可以关闭 Emacs 中的警告音，

#+BEGIN_SRC lisp
(setq ring-bell-function 'ignore)
#+END_SRC

每一次当 Emacs 需要与你确认某个命令时需要输入 =(yes or no)= 比较麻烦，所有我们可以使用下面的代码，设置一个别名将其简化为只输入 =(y or n)= 。

#+BEGIN_SRC lisp
(fset 'yes-or-no-p 'y-or-n-p)
#+END_SRC

*** 代码缩进

=indent-region= 可以帮我们重新缩进所选区域的代码，但是每一次都选中十分麻烦。使用下面的代码可以一次重新缩进全部缓冲区的代码。（之后也会介绍更好用的，代码格式美化的插件）

#+BEGIN_SRC lisp
  (defun indent-buffer()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun indent-region-or-buffer()
    (interactive)
    (save-excursion
      (if (region-active-p)
          (progn
            (indent-region (region-beginning) (region-end))
            (message "Indent selected region."))
        (progn
          (indent-buffer)
          (message "Indent buffer.")))))
#+END_SRC

然后再将其用下面的代码将其绑定为快捷键，第一个 =\= 用于将紧跟的 =\= 进行逃脱（escape）。

#+BEGIN_SRC lisp
(global-set-key (kbd "C-M-\\") 'indent-region-or-buffer)
#+END_SRC

*** 缩写补全

使用下面的代码我们可以开启 ~abbrev~ 模式并定义一个缩写表，每当我们输入下面的缩写并以空格结束时，Emacs 就会将其自动展开成为我们所需要的字符串。

#+BEGIN_SRC lisp
  (abbrev-mode t)
  (define-abbrev-table 'global-abbrev-table '(
                                              ;; Shifu
                                              ("8zl" "zilongshanren")
                                              ;; Tudi
                                              ("8lxy" "lixinyang")
                                             ))
#+END_SRC

上面的缩写前使用的 ~8~ 也类似于命名空间的作用，使其不会与我们所常用的字符串冲突。

*** Hippie 补全

Company 有时候补全功能并不是非常理想，这时就可以使用 Hippie Expand 来完成补全。Company Mode 补全效果不理想的原因是在不同的区域中会使用不同的后端函数来完成补全，但是当后端补全函数不能被激活时，则补全就不会被激活。


我们可以将下面的代码加入到我们的配置文件中，来增强 Hippie Expand 的功能，

#+BEGIN_SRC lisp
  (setq hippie-expand-try-function-list '(try-expand-debbrev
                                          try-expand-debbrev-all-buffers
                                          try-expand-debbrev-from-kill
                                          try-complete-file-name-partially
                                          try-complete-file-name
                                          try-expand-all-abbrevs
                                          try-expand-list
                                          try-expand-line
                                          try-complete-lisp-symbol-partially
                                          try-complete-lisp-symbol))
#+END_SRC

然后将其绑定为快捷键，使我们可以更方便的使用它。

#+BEGIN_SRC lisp
(global-set-key (kbd "s-/") 'hippie-expand)
#+END_SRC
** Dired Mode

Dired Mode 是一个强大的模式它能让我们完成和文件管理相关的所有操作。

使用 =C-x d= 就可以进入 Dired Mode，这个模式类似于图形界面系统中的资源管理器。你可以在其中查看文件和目录的详细信息，对他们进行各种操作，甚至复制粘贴缓冲区中的内容。下面是一些常用的操作（下面的所有键均需在 Dired Mode 下使用），

- =+= 创建目录
- =g= 刷新目录
- =C= 拷贝
- =D= 删除
- =R= 重命名
- =d= 标记删除
- =u= 取消标记
- =x= 执行所有的标记

这里有几点可以优化的地方。第一是删除目录的时候 Emacs 会询问是否递归删除或拷贝，这也有些麻烦我们可以用下面的配置将其设定为默认递归删除目录（出于安全原因的考虑，也许你需要保持此行为。所有文中的配置请务必按需配置）。

#+BEGIN_SRC lisp
(setq dired-recursive-deletes 'always)
(setq dired-recursive-copies 'always)
#+END_SRC

第二是，每一次你进入一个回车进入一个新的目录中是，一个新的缓冲区就会被建立。这使得我们的缓冲区列表中充满了大量没有实际意义的记录。我们可以使用下面的代码，让 Emacs 重用唯一的一个缓冲区作为 Dired Mode 显示专用缓冲区。

#+BEGIN_SRC lisp
(put 'dired-find-alternate-file 'disabled nil)

;; 主动加载 Dired Mode
;; (require 'dired)
;; (defined-key dired-mode-map (kbd "RET") 'dired-find-alternate-file)

;; 延迟加载
(with-eval-after-load 'dired
    (define-key dired-mode-map (kbd "RET") 'dired-find-alternate-file))
#+END_SRC

使用延迟加载可以使编辑器加载速度有所提升。

启用 =dired-x= 可以让每一次进入 Dired 模式时，使用新的快捷键 =C-x C-j= 就可以进入当前文件夹的所在的路径。

#+BEGIN_SRC lisp
(require 'dired-x)
#+END_SRC

使用 =(setq dired-dwin-target t)= 则可以使当一个窗口（frame）中存在两个分屏（window）时，将另一个分屏自动设置成拷贝地址的目标。

最后如果你是 Mac OS X 的用户，可以安装 =reveal-in-osx-finder= 这个插件（你可以在[[https://melpa.org/#/reveal-in-osx-finder][这里]]找到它），他可以将任意文件直接在 Finder 中打开。你要做的就是将其添加至，第二天的插件列表中即可，下载启动 Emacs 时，它就会自动帮你完成下载。
** Org-mode 管理 Emacs 配置

Org-mode 下的文学编程将颠覆你对于 Emacs 的看法。因为我们也可以使用 Org 来管理 Emacs 的配置文件（笔者和他的师傅其实更倾向于模块管理配置文件）。

你需要将下面的代码放入配置入口文件（ =init.el= ）中，

#+BEGIN_SRC lisp
(package-initialize)

(require 'org-install)
(require 'ob-tangle)
(org-babel-load-file (expand-file-name "org-file-name.org" user-emacs-directory))
#+END_SRC

之后我们需要做的仅仅只是将所有的配置文件放入 Org 模式中的代码块即可，并使用目录结构来表述你的配置文件再把它保存在与入口文件相同的目录中即可（文件名为 ~org-file-name.org~ ）。Emacs 会提取其中的配置并使其生效。这样做的好处是可以使自己和他人更直观的，理解你的配置文件或者代码。

** COMMENT Some issues here
Org-mode might has conflicts with other modes. It will be better if you mention that
you should wrap the org-mode configuration in code like this:
(with-eval-after-load 'org
 ;;; someyoru configurations here:
 )
 
